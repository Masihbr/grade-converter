# grade-converter
Sharif.edu based gpa-calculator (GPA based on 4) - web backend with Authentication - Average grade seperation based on the course being major or not 

# گزارش کار
## ساخت مخزن
<div align="center">
<img align="center" src=https://github.com/Masihbr/grade-converter/assets/56260232/5e5ffeee-4c6a-4d17-9f90-c77c5ec130b4>
<img align="center" src=https://github.com/Masihbr/grade-converter/assets/56260232/388a55ff-caf3-4112-80c4-dffcf7da88e7>
</div>

## ساخت قانون محافظت از شاخه اصل
<div align="center">
<img align="center" src=https://github.com/Masihbr/grade-converter/assets/56260232/d9c40667-41d5-46fe-a687-2888e44510fe>
<img align="center" src=https://github.com/Masihbr/grade-converter/assets/56260232/3be3b8a1-4ad0-4abc-bc3e-0a7cb544ba4f>
<img align="center" src=https://github.com/Masihbr/grade-converter/assets/56260232/0fe66d53-41ae-4acb-9f0d-f953d31f5fa6>
</div>

## پروسه ادغام دو شاخه 
همانطور که در اولین تصویر قابل مشاهده است برای مرج کردن دو شاخه ابتدا باید یک درخواست pull request از شاخه ای که میخواهید مرج کنید به شاخه مقصد میزنید و میتوانید برای این درخواستتان توضیحاتی نیز ارائه دهید. در ابتدا بصورت اتوماتیک خود گیت چک میکند که ایا این دو شاخه با هم تناقضی دارند یا خیر در صورت نبود تناقض به شما این اجازه را میدهد که به سادگی pull request را بسازید.


گام بعدی این پروسه همینطور که در تصویر پایین مشاهده میکنید تایید مرج این pull request است که در اینجا میتوانید تغییراتی که میخواهید مرج کنید را در مقایسه و کنار کد های همان بخش ها در شاخه مقصد مشاهده کنید.


همانطور که در تصویر پایین مشاهده میکنید پس از اعلام درخواست مرج باز هم از شما به عنوان تایید کننده این pull request یک تایید ثانویه میخواهد.


در مرحله اخر pull request به سرانجام میرسد و به حالت merged میرود و تغییرات بر روی commit history شاخه مقصد می‌نشیند.

## پرسش‌ها

1. 
.git
یک دایرکتوری پنهان در root یک ریپوی گیت است. یکی از بنیادی‌ترین اجزای پروسه مدیریت و ذخیره سازی دیتا در گیت است. این دایرکتوری تمامی اطلاعات و متادیتا مربوط به ریپوی گیت شما را در خود شامل می‌شود. مواردی همچون تاریخچه کاملی از پروژه، شاخه ها، تگ ها و ...
چندتا از موارد مهمی که در این دایرکتوری حضور دارند را بررسی میکنیم.
- config 
این فایل شامل تنظیمات مربوط به configuration ریپو میباشد.
- HEAD 
یک فایل است که به شاخه ای که در حال حاضر در جریان کار است و به آن checkout کردید اشاره میکند.
- index
یک فایل است که یک محیطی تحت عنوان staging برای ریپو فراهم میکند. این محیط همان جایی است که تغییرات پیش از کامیت شدن به آن اضافه می‌شوند.
- logs
یک سری از فایل‌ها هستند که شامل لاگ های مربوط به بخش های مختلف از ریپو هستند.
- description
یک فایل text ساده که یک توصیف کوتاه راجع به ریپازیتوری را شامل می‌شود.
- Refs
یک سری از رفرنس به کامیت ها است برای مثال رفرنس به head تگ ها و شاخه های مختلف.
- Objects
دایرکتوری که در حال بررسی آن میباشیم حتی تمام داده هایی که بر روی ریپو باید ذخیره شوند را نیز شامل میشود و آن ها را با data structure های خاص خودش در خود ذخیره میکند.
بطور معمول وقتی در حال _initiate_ یک ریپو با استفاده از دستور **_git init_** هستید این دایرکتوری ساخته می‌شود.

2. 
در نگاه کلی و منطقی همانطور که در مورد کار با پایگاه داده ها و سرورها از این مفهوم استفاده میشود در اینجا هم تفکر کلی به همان شکل است. atomic بودن به معنی غیرقابل تقسیم بودن است. یعنی یک اتفاق به یکباره تماما اجرا شود بدون اینکه چیزی در میان اجرا آنرا قطع کند. این مفهوم به منظور برقراری پایداری و امکان توسعه ایمن با همکاری دیگران مورد استفاده قرار گرفته است.
- این مفهوم در کامیت بدین معنی است که تغییراتی که در یک کامیت قرار داده اید یا بصورت کامل کامیت میشوند و یا در غیراینصورت تمام انها کامیت نشده تلقی میشوند. در ضمن این مفهوم به علاوه این موضوع که تغییرات مربوط به یک فیچر یا یک تسک را باید در یک کامیت قرار داد به پایداری سیستم و قابل فهم تر و دسترسی پذیرتر بودن تاریخچه تغییرات کمک میکنند.
- اما در مورد pull requests این مفهوم بدین معنی است که هر pull request شامل یک مجموعه از تغییرات است میتواند در شاخه main بصورت یک unit مرج شود (دوباره ارجاع به همان موضع منطقی که اگر بخشی از آن مرج نشود بدین معنی است که کاملا مرج نشده است.)

3. 
ابتدا به تشریح کارکرد هرکدام از این دستورات میپردازیم و سپس انها را با هم مقایسه میکنیم.
- fetch
از این دستور برای اپدیت ریپازیتوری محلی و هماهنگ سازی آن با تغییرات روی ریپوی ریموت استفاده کرد. این دستور تغییری بر روی شاخه فعلی مورد استفاده شما ایجاد نمیکند و تنها میرود و تغییراتی که بر روی ریپوی ریموت ایجاد شده است را می اورد تا در دسترس باشند که خوب این موضوع سبب میشود که در کل دستور ایمنی باشد.
- pull
یک ترکیبی از دو دستور git fetch و git merge است. تغییرات ریپو ریموت را می‌آورد و پس از آن تغییرات آورده شده را در شاخه در جریان ادغام میکند. این دستور یکی از ساده ترین راه ها برای سینک کردن ریپوی محلی با ریپوی ریموت است و خوب بدلیل مرحله ادغامی که دارد این امکان وجود دارد که به کانفلیکت بخورد و کدهای محلی شما با تغییرات ریموت دچار تناقض باشند.
- merge
از این دستور برای ترکیب کردن تغییرات بر روی یک شاخه با تغییرات شاخه دیگر استفاده میشود. این ادغام تحت یک کامیت چدید انجام میگیرد.
- rebase
از این دستور برای انتقال یا ترکیب یک توالی از کامیت ها از یک شاخه به شاخه دیگر استفاده میشود. کاری که این دستور میکند دستکاری تاریخچه تغییرات و کامیت های شاخه مقصد است و مسیر گراف تغییرات را از لایه های بالاتر تغییر میدهد.
- cherry-pick
این دستور این قابلیت را به کاربر میدهد تا یک یا چند کامیت را به صورت گزینشی و بدون اینکه نیاز باشد تا کل شاخه را در دیگری ادغام کنیم بر روی شاخه دیگر اعمال کنیم.

بطور کلی هم میتوان گفت که fetch و pull برای اوردن تغییرات ریموت سمت لوکال مورد استفاده قرار میگیرند حال با تفاوت های ریزی که بالاتر گفته شد. merge و rebase و cherry-pick هم برای جابجایی و اعمال ادغام کامیت ها بین شاخه های مختلف هستند که تفاوت های هر یک از انها در کارکرد هایشان که بالاتر توضیح داده شده اند مشخص است.

4. 
اولین گام برای مقایسه این سه دستور این است که به تعریف شرح وظایف هرکدام از آنها بپردازیم.
- reset
از این دستور برای جابجا کردن HEAD و branch pointer به یک کامیت مشخص استفاده میکنند. مشخصا این عمل سبب میشود که شاخه از یک حالت وارد حالت دیگری شود و در قسمت دیگری از گراف تغییرات قرار گیرد.
با استفاده از این قابلیت میتوان تغییرات اعمال شده را به حالت قبل برگرداند یا حتی تاریخچه تغییرات را بازنویسی کرد.
- revert
این دستور این قابلیت را به کاربر میدهد تا با ایجاد یک کامیت جدید بتواند تمام تغییراتی که در کامیت اخر خود اعمال کرده است را undo کند.
همین کار را reset هم میتواند انجام دهد ولی تفاوتی که این دستور دارد این است که دیگر نیازی به ایجاد تغییرات در تاریخچه تغییرات نیست.
- restore
این دستور برای انتقال فایل های دایرکتوری که در حال کار بر روی ان هستید به یک استیت دیگر مورد استفاده قرار میگیرد این دستور بیشتر تمرکزش بر روی فایل ها است ولی تقریبا همان قابلیت های ریست را به ما عرضه میکند و بدون دخالت در تاریخچه تغییرات میتوایم از تغییراتی که قبلا اعمال کردیم ضرفنظر کنیم.

5. 
stage 
به پروسه اماده سازی تغییرات در working directory برای گنچاندن آنها در کامیت بعدی اشاره دارد. در واقع یک لایه میانی بین working directory به عنوان جایی که تغییرات در حال ایجاد شدن هستند و commit history به عنوان جایی که تغییرات به عنوان کامیت وارد گراف تاریخچه میشوند عمل میکند. وقتی شما تغییری در working directory ایجاد میکنید برای اینکه بتوانید بعدا آن را تبدیل به کامیت کنید باید با استفاده از دستور git add آن تغییر را به یک مرحله میانی ببرید تا پس از اعمال دستور کامیت در گیت، گیت بتواند تشخیص دهد که کدام تغییرات را باید کامیت کند و کدام تغییرات را نباید وارد تاریخچه کند. 
- git stash
دستوری است که به کاربر این امکان را میدهد تا تغییراتش را که هنوز امادگی کامیت شدن ندارند را بر روی current working directory خود ذخیره کند تا بتواند بدون مشکل به برنچ های دیگر برود و کار های دیگری انجام دهد و هر موقع اراده کرد به برنچ قبلی برگردد و باز هم بدون از دست دادن تغییرات خود انها را لود کند و به کار خود ادامه دهد. 

6. 
در ابتدا به تعیرف این مفهوم میپردازیم.
- snapshot
یک نمایش کامل و read-only از استیت پروژه است. دقیقا همانند این است که در یک لحظه خاص از پروژه خود یک عکس بگیرید و در آن عکس استیت تمامی فایل ها و محتوایشان مشخص باشد.
کامیت هم در واقع یک نمونه ای از snapshot پروژه در تاریخجه ریپو است. وقتی شما یک کامیت جدید میسازید در واقع دارید یک snapshot جدید از استیت پروژه تان میسازید. گیت هم بطور کلی تغییرات بین snapshot های مختلف را ذخیره نمیکند. در عوض تمامی محتوا و شرایط پروژه را در هر کامیت ذخیره میکند. در وافع این مفهوم است که سبب میشود کاربر بتواند براحتی در تاریخچه پروژه جلو و عقب برود و تغییر ایجاد کند و از قابلیت هایی مثل branching و merging استفاده کند.
